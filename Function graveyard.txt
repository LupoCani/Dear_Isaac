/*struct get_expiry
	{
		//With this many return variables, it's easier to make it a single-function class
		vector<body*> list_out;
		vector<vector<pred_p>> mins_out;
		bool will_expire;
		double V_exp;
		double expire_time;
		int new_parent;

		get_expiry(body &sat, vector<body*> list)
			//This one's gonna be tough.
		{
			vector<body*> list_in = list;
			vector<double> starts;			//Current V-values for bodies
			vector<double> ends;			//V-values for bodies at the end of the relevant time span
			vector<double> diffs;
			list.clear();
			int precision;
			int precision_base = 1000;

			
			//We'll try to find if there's any body, orbiting the same parent as the player, into whose SOI the player will enter, and when.
			//We could just check a lot of moments in time with do_orbit(), but that function is expensive as hell.

			//Instead, we use the inverse process. We check an interval of values of V for the player

			//Cont' TBA
			

			double start, end, diff, start_t, end_t;

			start_t = sat.safe;
			end_t = sat.expiry();

			double fidelty = 20;
			int t_fid = 15;

			vec_n sat_pos, sat_pos_old;
			double sat_tim, sat_tim_old;
			{
				vec_n cur_pos, end_pos;

				do_orbit(sat, start_t, fidelty, cur_pos);
				do_orbit(sat, end_t, fidelty, end_pos);

				start = get_V_phys(sat, cur_pos);
				end = get_V_phys(sat, end_pos);

				start = ang_wrap(start);

				double laps = 0;
				if (sat.ecc < 0.9999999999)
					laps = floor((end_t - start_t) / sat.t_p) * sat.t_p;

				int ilog = 0;
				while (end <= start + laps)
				{
					end += M_2PI;

					ilog++;
				}

				//end += M_2PI;

				diff = end - start;
				sat_pos = cur_pos;
				sat_tim = start_t;
			}


			for (int i = 0; i < list_in.size(); i++)
			{
				body &pln = *list_in[i];
				if (pln.parent == sat.parent && !(pln.isPlayer || pln.isSun))
				{
					vec_n cur_pos, end_pos;
					do_orbit(pln, start_t, fidelty, cur_pos);
					do_orbit(pln, end_t, fidelty, end_pos);

					double pln_start = get_V_phys(pln, cur_pos);
					double pln_end = get_V_phys(pln, end_pos);

					pln_start = ang_wrap(pln_start);

					double laps = floor((end_t - start_t) / pln.t_p);
					while (pln_end < pln_start + laps * M_2PI)
						pln_end += M_2PI;

					starts.push_back(pln_start);			//Get the current true anomaly of the body. 
					ends.push_back(pln_end);

					list.push_back(pln.self);
					diffs.push_back(pln_end - pln_start);
				}
			}

			vector<vector<pred_p>> mins(list.size());

			vector<double> last_times(list.size(), start_t - pow(10.0, -10.0));
			vector<int>	its(list.size(), 0);
			vector<short> dlts(list.size(), 1);
			vector<unsigned char> past_peak(list.size(), false);

			pred_p basic_queue_point(0, 0);
			vector<pred_p> basic_queue(10, basic_queue_point);

			vector<vector<pred_p>> logs_td(list.size(), basic_queue);
			basic_queue.clear();
			vector<vector<pred_p>> pred_lists(list.size(), basic_queue);

			int end_body = -1;
			double end_time = DBL_MAX;
			double end_V = NAN;
			bool ending = false;

			if (list.size())
			{
				precision = precision_base * ((end)-start) / M_2PI;
				if (precision < precision_base / 20)
					precision = precision_base / 20;


				for (int i2 = 0; i2 < precision; i2++)
				{
					double Vs = start + ang_scale(diff, i2, precision);

					sat_pos_old = sat_pos;
					sat_tim_old = sat_tim;

					sat_pos = get_pos_ang(Vs, sat);
					sat_tim = M_to_time(sat, get_M(Vs, sat.ecc), sat_tim_old, t_fid);

					vec_n sat_pos_diff = sat_pos - sat_pos_old;
					double sat_tim_diff = sat_tim - sat_tim_old;


					for (int i = 0; i < list.size(); i++)
					{
						body &pln = *list[i];
						double Vp = starts[i] + ang_scale(diffs[i], its[i], precision);
						double pln_tim = M_to_time(pln, get_M(Vp, pln.ecc), last_times[i], t_fid);
						last_times[i] = pln_tim;
						vec_n pln_pos = get_pos_ang(Vp, pln);

						while (pln_tim < sat_tim_old)
						{
							its[i]++;
							Vp = starts[i] + ang_scale(diffs[i], its[i], precision);
							pln_tim = M_to_time(pln, get_M(Vp, pln.ecc), last_times[i], t_fid);
							last_times[i] = pln_tim;
						}

						while (pln_tim < sat_tim)
						{
							double diff_part = (pln_tim - sat_tim_old) / sat_tim_diff;	//What percentage of the current time interval has passed in the moment we're observing.
							vec_n sat_pos_est = sat_pos_old + sat_pos_diff * diff_part;
							vec_n pln_pos = get_pos_ang(Vp, pln);
							double dist_est = vmag(sat_pos_est - pln_pos);
							short dlt_new;

							pred_p pln_td(dist_est, pln_tim);

							logs_td[i].push_back(pln_td);
							logs_td[i].erase(logs_td[i].begin());

							if (logs_td[i][0].dist > logs_td[i].back().dist)
								dlt_new = -1;
							else
								dlt_new = 1;

							if (dlts[i] != dlt_new)
							{
								pred_p queue_ext = logs_td[i][0];
								for (int i3 = 0; i3 < logs_td[i].size(); i3++)
									if (queue_ext.dist < logs_td[i][i3].dist == dlt_new > 0)
										queue_ext = logs_td[i][i3];

								queue_ext.dlt = dlt_new;

								pred_lists[i].push_back(queue_ext);

								dlts[i] = dlt_new;
							}
							if (pln_td.dist < pln.SOI && (pln_tim < end_time || !ending))
							{
								ending = true;
								end_body = i;
								end_time = pln_tim;
								end_V = Vs;
								break;
							}

							if (pln_td.dist < logs_td[i][0].dist)
								past_peak[i] = true;
							
							its[i]++;
							Vp = starts[i] + ang_scale(diffs[i], its[i], precision);
							pln_tim = M_to_time(pln, get_M(Vp, pln.ecc), last_times[i], t_fid);
							last_times[i] = pln_tim;
						}
					}
				}
			}

			for (int i = 0; i < list.size(); i++)
				for (int i2 = 0; i2 < pred_lists[i].size(); i2++)
					if (pred_lists[i][i2].dlt > 0)
						mins[i].push_back(pred_lists[i][i2]);
				
			list_out = list;
			will_expire = ending;
			new_parent = end_body;
			expire_time = end_time;
			V_exp = end_V;

			mins_out = mins;
		}
	};
	*/
	
	struct get_expiry_slow
	{
		//With this many return variables, it's easier to make it a single-function class
		vector<body*> list_out;
		vector<vector<pred_p>> mins_out;
		bool will_expire;
		double V_exp;
		double expire_time;
		int new_parent;

		get_expiry_slow(body &sat, vector<body*> list)
			//This one's gonna be tough.
		{
			vector<body*> list_in = list;
			vector<double> starts;			//Current V-values for bodies
			vector<double> ends;			//V-values for bodies at the end of the relevant time span
			vector<double> diffs;
			list.clear();
			int precision;
			int precision_base = 1000;

			/*
			We'll try to find if there's any body, orbiting the same parent as the player, into whose SOI the player will enter, and when.
			We could just check a lot of moments in time with do_orbit(), but that function is expensive as hell.

			Instead, we use the inverse process. We check an interval of values of V for the player

			Cont' TBA
			*/

			double start, end, diff, start_t, end_t;

			start_t = sat.safe;
			end_t = sat.expiry();

			double fidelty = 20;
			int t_fid = 15;

			vec_n sat_pos, sat_pos_old;
			double sat_tim, sat_tim_old;
			{
				vec_n cur_pos, end_pos;

				do_orbit(sat, start_t, fidelty, cur_pos);
				do_orbit(sat, end_t, fidelty, end_pos);

				start = get_V_phys(sat, cur_pos);
				end = get_V_phys(sat, end_pos);

				start = ang_wrap(start);

				double laps = 0;
				if (sat.ecc < 0.9999999999)
					laps = floor((end_t - start_t) / sat.t_p) * sat.t_p;

				int ilog = 0;
				while (end <= start + laps)
				{
					end += M_2PI;

					ilog++;
				}

				diff = end - start;
				sat_pos = cur_pos;
				sat_tim = start_t;
			}


			for (int i = 0; i < list_in.size(); i++)
			{
				body &pln = *list_in[i];
				if (pln.parent == sat.parent && !(pln.isPlayer || pln.isSun))
				{
					vec_n cur_pos, end_pos;
					do_orbit(pln, start_t, fidelty, cur_pos);
					do_orbit(pln, end_t, fidelty, end_pos);

					double pln_start = get_V_phys(pln, cur_pos);
					double pln_end = get_V_phys(pln, end_pos);

					pln_start = ang_wrap(pln_start);

					double laps = floor((end_t - start_t) / pln.t_p);
					while (pln_end < pln_start + laps * M_2PI)
						pln_end += M_2PI;

					starts.push_back(pln_start);			//Get the current true anomaly of the body. 
					ends.push_back(pln_end);

					list.push_back(pln.self);
					diffs.push_back(pln_end - pln_start);
				}
			}

			vector<vector<pred_p>> mins(list.size());

			vector<double> last_times(list.size(), start_t - pow(10.0, -10.0));
			vector<int>	its(list.size(), 0);
			vector<short> dlts(list.size(), 1);
			vector<unsigned char> past_peak(list.size(), false);

			pred_p basic_queue_point(0, 0);
			vector<pred_p> basic_queue(10, basic_queue_point);

			vector<vector<pred_p>> logs_td(list.size(), basic_queue);
			basic_queue.clear();
			vector<vector<pred_p>> pred_lists(list.size(), basic_queue);

			int end_body = -1;
			double end_time = DBL_MAX;
			double end_V = NAN;
			bool ending = false;

			if (list.size())
			{
				precision = precision_base * ((end)-start) / M_2PI;
				if (precision < precision_base / 20)
					precision = precision_base / 20;


				for (int i2 = 0; i2 < precision; i2++)
				{
					double Vs = start + ang_scale(diff, i2, precision);

					sat_pos_old = sat_pos;
					sat_tim_old = sat_tim;

					sat_pos = get_pos_ang(Vs, sat);
					sat_tim = M_to_time(sat, get_M(Vs, sat.ecc), sat_tim_old, t_fid);

					vec_n sat_pos_diff = sat_pos - sat_pos_old;
					double sat_tim_diff = sat_tim - sat_tim_old;


					for (int i = 0; i < list.size(); i++)
					{
						body &pln = *list[i];
						double Vp = starts[i] + ang_scale(diffs[i], its[i], precision);
						double pln_tim = M_to_time(pln, get_M(Vp, pln.ecc), last_times[i], t_fid);
						last_times[i] = pln_tim;
						vec_n pln_pos = get_pos_ang(Vp, pln);


						{
							double diff_part = (pln_tim - sat_tim_old) / sat_tim_diff;	//What percentage of the current time interval has passed in the moment we're observing.
							vec_n sat_pos_est = sat_pos_old + sat_pos_diff * diff_part;
							vec_n pln_pos = get_pos_ang(Vp, pln);
							double dist_est = vmag(sat_pos_est - pln_pos);
							short dlt_new;

							pred_p pln_td(dist_est, pln_tim);

							logs_td[i].push_back(pln_td);
							logs_td[i].erase(logs_td[i].begin());

							if (logs_td[i][0].dist > logs_td[i].back().dist)
								dlt_new = -1;
							else
								dlt_new = 1;

							if (dlts[i] != dlt_new)
							{
								pred_p queue_ext = logs_td[i][0];
								for (int i3 = 0; i3 < logs_td[i].size(); i3++)
									if (queue_ext.dist < logs_td[i][i3].dist == dlt_new > 0)
										queue_ext = logs_td[i][i3];

								queue_ext.dlt = dlt_new;

								pred_lists[i].push_back(queue_ext);

								dlts[i] = dlt_new;
							}
							if (pln_td.dist < pln.SOI && (pln_tim < end_time || !ending))
							{
								ending = true;
								end_body = i;
								end_time = pln_tim;
								end_V = Vs;
								break;
							}

							if (pln_td.dist < logs_td[i][0].dist)
								past_peak[i] = true;

							its[i]++;
							Vp = starts[i] + ang_scale(diffs[i], its[i], precision);
							pln_tim = M_to_time(pln, get_M(Vp, pln.ecc), last_times[i], t_fid);
							last_times[i] = pln_tim;
						}
					}
				}
			}

			for (int i = 0; i < list.size(); i++)
				for (int i2 = 0; i2 < pred_lists[i].size(); i2++)
					if (pred_lists[i][i2].dlt > 0)
						mins[i].push_back(pred_lists[i][i2]);

			list_out = list;
			will_expire = ending;
			new_parent = end_body;
			expire_time = end_time;
			V_exp = end_V;

			mins_out = mins;
		}
	};

	void get_expiry_phys(body &sat, vector<body*> list, vector<body*> &list_out, vector<vector<double>> &mins_out, bool &will_expire, int &new_parent)
	{
		vector<body*> list_in = list;
		list.clear();
		int precision;
		int precision_base = 1000;

		vector<double> min_dists;
		vector<double> min_times;

		int fidelty = 10;
		double start_t = sat.safe;
		double end_t = sat.expiry();

		for (int i = 0; i < list_in.size(); i++)
		{
			body &pln = *list_in[i];
			if (pln.parent == sat.parent && !(pln.isPlayer || pln.isSun))
			{
				vec_n cur_pos, end_pos;
				do_orbit(pln, start_t, fidelty, cur_pos);
				do_orbit(pln, end_t, fidelty, end_pos);

				double pln_start = get_V_phys(pln, cur_pos);
				double pln_end = get_V_phys(pln, end_pos);

				pln_start = ang_wrap(pln_start);

				double laps = floor((end_t - start_t) / pln.t_p);
				while (pln_end < pln_start + laps * M_2PI)
					pln_end += M_2PI;


				list.push_back(pln.self);

				min_times.push_back(DBL_MAX);
				min_dists.push_back(DBL_MAX);
			}
		}


		vector<body*> list_original = list;
		body parent = *(*list[0]).parent;
		parent.self = &parent;
		body sat_cp = sat;


		int end_body = -1;
		double end_time = DBL_MAX;
		bool ending = false;


		if (list.size())
		{
			//precision = precision_base * ang_wrap(end - start) / M_2PI;
			precision = precision_base;
			if (precision < precision_base / 20)
				precision = precision_base / 20;

			list.push_back(&sat_cp);

			for (int i = 0; i < list.size(); i++)
			{
				body new_bod = *list[i];
				list[i] = &new_bod;
				new_bod.parent = &parent;
				new_bod.self = list[i];

				new_bod.vel -= parent.vel;
				new_bod.pos -= parent.pos;
				new_bod.t_l = 0;
			}
			parent.pos = 0;
			parent.vel = 0;

			vec_n sat_pos_old;
			double sat_tim_old = 0;
			double span = sat.expiry() - sat.safe;


			for (int i2 = 0; i2 < precision; i2++)
			{

				double s_time = span * ((i2 + 1) / precision);

				for (int i = 0; i < list.size(); i++)
				{
					body &pln = *list[i];

					vec_n new_pos, new_vel;
					do_orbit_phys(pln, sat.safe, vec_n(), new_pos, new_vel);

					pln.pos = new_pos;
					pln.vel = new_vel;

				}
				for (int i = 0; i < list.size()-1; i++)
				{
					body &pln = *list[i];
					double dist = vmag(sat_cp.pos - pln.pos);

					if (dist < min_dists[i])
					{
						min_dists[i] = dist;
						min_times[i] = s_time;

						if (dist < pln.SOI && (s_time < end_time || !ending))
						{
							ending = true;
							end_body = i;
							end_time = s_time;
						}
					}
					else if (dist < pln.SOI)
					{
						if (end_body == i)
							break;
					}
				}
			}
		}


		list.pop_back();

		list_out = list_original;
		will_expire = ending;
		new_parent = end_body;

		mins_out.push_back(min_dists);
		mins_out.push_back(min_times);
	}

	/*
	void do_predict_new()
	{
		using gen::bodies;
		using namespace pred;

		bool invalid = pred::invalid;
		pred::invalid = false;

		body &plyr = *bodies.back();
		int digits = 6;

		if (shared::r_time < gen::last_predict + shared::cps * 0.1) return;
		if (plyr.inverse) return;

		get_expiry data(plyr, gen::bodies);

		vector<body*> co_sats = data.list_out;

		vector<vector<pred_p>> pairs = data.mins_out;

		vector<int> cnv;	//Table for translating the prediction function's indexes to regular bodies indexes.

		for (int i = 0; i < pairs.size(); i++)
			for (int i2 = 0; i2 < bodies.size(); i2++)
				if (bodies[i2] == co_sats[i])
					cnv.push_back(i2);

		bool expiring = data.will_expire;
		int new_parent = data.new_parent;
		double expire_time = data.expire_time;

		if (expiring)
			std::cout << "New parent: " << (*co_sats[new_parent]).name <<"\n";

		for (int i = 0; i < pairs.size(); i++)
		{
			int ip = cnv[i];
			body &pln = *bodies[ip];

			if (expiring && i == new_parent) continue;

			for (int i2 = 0; i2 < pairs[i].size(); i2++)
			{
				vector<double> dists(3);

				double t_part = (pln.t_p / 1000);

				for (int i3 = 0; i3 < dists.size(); i3++)
				{
					vec_n true_pos_plyr, true_pos_pln;

					double tdiff = t_part * (i3 - 1);

					do_orbit(plyr, pairs[i][i2].time + tdiff, digits, true_pos_plyr);
					do_orbit(pln,  pairs[i][i2].time + tdiff, digits, true_pos_pln);

					dists[i3] = vmag(true_pos_plyr - true_pos_pln);
				}

				if (dists[0] < dists[1] && dists[1] > dists[2])	//If the point is literally a local maximum, be rid of it.
				{
					pop_any(pairs[i], i2);
					i2--;
					continue;
				}

				int orbits_done = 0;
				int budget = 100;

				for (int i3 = 2; dists[1] > dists[2]; i3++)
				{
					vec_n true_pos_plyr, true_pos_pln;

					double tdiff = t_part * i3;

					do_orbit(plyr, pairs[i][i2].time + tdiff, digits, true_pos_plyr);
					do_orbit(pln, pairs[i][i2].time + tdiff, digits, true_pos_pln);

					double true_dist = vmag(true_pos_plyr - true_pos_pln);

					pop_any(dists, 0);
					dists.push_back(true_dist);

					orbits_done++;

					if (orbits_done > budget)
					{
						std::cout << "Budget break forwards! \n";
						break;
					}
				}

				for (int i3 = 2; dists[1] > dists[0]; i3++)
				{
					vec_n true_pos_plyr, true_pos_pln;

					double tdiff = t_part * -i3;

					do_orbit(plyr, pairs[i][i2].time + tdiff, digits, true_pos_plyr);
					do_orbit(pln,  pairs[i][i2].time + tdiff, digits, true_pos_pln );

					double true_dist = vmag(true_pos_plyr - true_pos_pln);

					push_any(dists, 0, true_dist);
					dists.pop_back();

					orbits_done++;

					if (orbits_done > budget)
					{
						std::cout << "Budget break forwards! \n";
						break;
					}
				}

				pairs[i][i2].dist = dists[1];

				if (dists[0] < dists[1] || dists[1] > dists[2])	//If the point is still not a local minimum, be rid of it.
				{
					pop_any(pairs[i], i2);
					i2--;
					continue;
				}
			}
		}

		plyr.safe = plyr.t_l;


		vector<bool> complete;
		int cur_id = -1;

		for (int i = 0; i < bodies.size(); i++)
			complete.push_back(1);

		for (int i = 0; i < pairs.size(); i++)
		{
			complete[cnv[i]] = pairs[i].size();
		}
		
		if (expiring)
		{
			plyr.entering = true;

			
			//vec_n true_pos_plyr, true_pos_pln;
			body &pln = *bodies[cnv[new_parent]];

			//do_orbit(plyr, expire_time, 10, true_pos_plyr);
			//do_orbit(pln,  expire_time, 10, true_pos_pln);

			//vmag(true_pos_plyr - true_pos_pln);
			
			
			plyr.V_ent = data.V_exp;

			std::cout << plyr.expire();

			pred::next_parent = cnv[data.new_parent];

			if (plyr.exiting ? expire_time <= plyr.exit : expire_time <= plyr.t_l + 2 * plyr.t_p)
				plyr.entry = expire_time;
		}
		else if (complete[pred::next_parent])
		{
			reset_expiry(plyr);
			set_expiry_regular(plyr);
			plyr.entering = false;

			std::cout << "Not expiring!\n";
			for (int i = 0; i < cnv.size(); i++)
			{
				if (cnv[i] == 4 && pairs[i].size())
					std::cout << pairs[i][0].dist << "\n";
			}
		}

		for (int i = 0; i < co_sats.size(); i++)
		{
			if (co_sats[i] == gen::bodies[game::target])
			{

				if (!pairs[i].size()) break;

				if (pairs[i][0].dist == DBL_MAX) break;

				game::min_dist = pairs[i][0].dist;
				game::min_time = pairs[i][0].time;

				break;
			}
		}
		gen::last_predict = shared::r_time;
	}

	*/

	/*
	void do_predict_safe()
	{
		using gen::bodies;
		using namespace pred;

		body &plyr = *bodies.back();

		if (shared::r_time < gen::last_predict + shared::cps * 0.1) return;
		if (plyr.inverse) return;

		get_expiry data(plyr, gen::bodies);

		vector<body*> co_sats = data.list_out;

		vector<vector<pred_p>> pairs = data.mins_out;

		vector<int> cnv;	//Table for translating the prediction function's indexes to regular bodies indexes.

		for (int i = 0; i < pairs.size(); i++)
			for (int i2 = 0; i2 < bodies.size(); i2++)
				if (bodies[i2] == co_sats[i])
					cnv.push_back(i2);

		bool expiring = data.will_expire;
		int new_parent = data.new_parent;
		double expire_time = data.expire_time;

		if (expiring)
			std::cout << "New parent: " << (*co_sats[new_parent]).name << "\n";

		for (int i = 0; i < pairs.size(); i++)
		{
			int ip = cnv[i];
			body &pln = *bodies[ip];

			if (expiring && i == new_parent) continue;

			for (int i2 = 0; i2 < pairs[i].size(); i2++)
			{
				vector<double> dists(3);

				double t_part = (pln.t_p / 1000);

				for (int i3 = 0; i3 < dists.size(); i3++)
				{
					vec_n true_pos_plyr, true_pos_pln;

					double tdiff = t_part * (i3 - 1);

					do_orbit(plyr, pairs[i][i2].time + tdiff, 10, true_pos_plyr);
					do_orbit(pln, pairs[i][i2].time + tdiff, 10, true_pos_pln);

					dists[i3] = vmag(true_pos_plyr - true_pos_pln);
				}

				if (dists[1] > dists[0] && dists[1] > dists[2])	//If the point is literally a local maximum, be rid of it.
				{
					pop_any(pairs[i], i2);
					i2--;
					continue;
				}

				int orbits_done = 0;
				int budget = 100;

				for (int i3 = 2; dists[1] > dists[2]; i3++)
				{
					vec_n true_pos_plyr, true_pos_pln;

					double tdiff = t_part * i3;

					do_orbit(plyr, pairs[i][i2].time + tdiff, 15, true_pos_plyr);
					do_orbit(pln, pairs[i][i2].time + tdiff, 15, true_pos_pln);

					double true_dist = vmag(true_pos_plyr - true_pos_pln);

					pop_any(dists, 0);
					dists.push_back(true_dist);

					orbits_done++;

					if (orbits_done > budget)
						break;
				}

				for (int i3 = 2; dists[1] > dists[0]; i3++)
				{
					vec_n true_pos_plyr, true_pos_pln;

					double tdiff = t_part * -i3;

					do_orbit(plyr, pairs[i][i2].time + tdiff, 15, true_pos_plyr);
					do_orbit(pln, pairs[i][i2].time + tdiff, 15, true_pos_pln);

					double true_dist = vmag(true_pos_plyr - true_pos_pln);

					push_any(dists, 0, true_dist);
					dists.pop_back();

					orbits_done++;

					if (orbits_done > budget)
						break;
				}

				pairs[i][i2].dist = dists[1];

				if (dists[1] > dists[0] || dists[1] > dists[2])	//If the point is still not a local minimum, be rid of it.
				{
					pop_any(pairs[i], i2);
					i2--;
				}

			}
		}

		plyr.safe = plyr.t_l;

		if (expiring)
		{
			plyr.entry = true;

			
			//vec_n true_pos_plyr, true_pos_pln;
			//body &pln = *bodies[cnv[new_parent]];

			//do_orbit(plyr, expire_time, 10, true_pos_plyr);
			//do_orbit(pln,  expire_time, 10, true_pos_pln);

			//vmag(true_pos_plyr - true_pos_pln);

			plyr.V_ent = data.V_exp;

			std::cout << pairs[new_parent].size() << "\n";

			if (plyr.shape ? expire_time <= plyr.expire() : expire_time <= plyr.t_l + 2 * plyr.t_p)
				plyr.entry = expire_time;
		}
		else
		{
			plyr.entering = false;
			std::cout << "Not expiring!\n";
		}

		for (int i = 0; i < co_sats.size(); i++)
		{
			if (co_sats[i] == gen::bodies[game::target])
			{

				if (!pairs[i].size()) break;

				if (pairs[i][0].dist == DBL_MAX) break;

				game::min_dist = pairs[i][0].dist;
				game::min_time = pairs[i][0].time;

				break;
			}
		}
		gen::last_predict = shared::r_time;
	}
	*/